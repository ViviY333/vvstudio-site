{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getBgColor(vec2 uv) {return vec3(1, 1, 1);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"aspectRatio":1.791713325867861,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"layerType":"image","width":1.1198208286674132,"widthMode":2,"height":1,"heightMode":0,"left":0.5,"top":0.5,"src":"https://assets.unicorn.studio/images/Zm6zZDe5mLe2U4kLQUZqP1Wlw8P2/bg3.png","imageNaturalSize":{"type":"Vec2","_x":736,"_y":482},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float absWidth = 1.1198 * uArtboardResolution.x;\nfloat absHeight = 1.0000 * uArtboardResolution.y;if (2 == 2) {\nabsWidth = absHeight * 1.7917;\n} else if (0 == 2) {\nabsHeight = absWidth / 1.7917;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.5000, 0.5000) * uArtboardResolution - getAnchorOffsets() * elementSizePx;vec2 centerPos = elementPosPx + (elementSizePx * 0.5);\nvec2 relPos = canvasPos - centerPos + mouseOffset;\nvec2 unrotatedRelPos = rotate2D(relPos, 0.0000 * -TAU);\nvec2 elementPos = unrotatedRelPos + (elementSizePx * 0.5);\nimageUV = elementPos / elementSizePx;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(736, 482), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 applyImageAdjustments(vec4 color) {\nvec3 exposureColor = clamp(color.rgb + -0.1000, 0.0, 1.0);\ncolor.rgb = mix(color.rgb, exposureColor, color.a);float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor.rgb = mix(vec3(luminance), color.rgb, 0.0600);vec3 contrasted = 1.3200 * (color.rgb - 0.5) + 0.5;\ncolor.rgb = mix(color.rgb, contrasted, color.a);color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getCompositeOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\ncolor = applyImageAdjustments(color);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0000 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getCompositeOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.791713325867861}}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"projection","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) {\nvec2 screenPos = (uv - 0.5) * 2.0;\nscreenPos.x *= aspect;\nscreenPos.y *= -1.0;\nfloat minFOV = radians(20.0);\nfloat maxFOV = radians(120.0);\nfloat fov = mix(minFOV, maxFOV, 0.0000);\nvec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0),\nscreenPos.y * tan(fov/2.0),\n-1.0));\nfloat rotX = (mousePos.y - 0.5) * PI;\nfloat rotY = (mousePos.x - 0.5) * PI * 2.0;\nmat3 rotateY = mat3(\ncos(rotY), 0.0, -sin(rotY),\n0.0, 1.0, 0.0,\nsin(rotY), 0.0, cos(rotY)\n);\nmat3 rotateX = mat3(\n1.0, 0.0, 0.0,\n0.0, cos(rotX), sin(rotX),\n0.0, -sin(rotX), cos(rotX)\n);\nreturn normalize(rotateX * rotateY * rayDir);\n}vec2 directionToUVHorizontal(vec3 dir) {\nfloat longitude = atan(dir.z, dir.x);\nfloat latitude = acos(dir.y);\nvec2 uv;\nuv.x = longitude / (2.0 * PI) + 0.5;\nuv.y = latitude / PI;\nuv.x += 0.25;\nreturn uv;\n}vec2 directionToUVVertical(vec3 dir) {\nfloat longitude = atan(dir.z, dir.y);\nfloat latitude = acos(dir.x);\nvec2 uv;\nuv.y = longitude / PI * -1.;\nuv.x = (latitude / (2.0 * PI) + 0.5) * -1.;\nuv.x = fract(uv.x + 0.25);\nreturn uv;\n}out vec4 fragColor;vec4 getRepeatHorizontalUV(vec2 uv) {\nvec2 finalUV = vec2(fract(uv.x), uv.y);\nvec4 col = texture(uTexture, finalUV);\nif (0.5500 > 0.0) {\nfloat blendWidth = 0.5500 * 0.1;\nfloat blendFactor = 0.0;\nif (finalUV.x < blendWidth) {\nblendFactor = 1.0 - (finalUV.x / blendWidth);\n} else if (finalUV.x > 1.0 - blendWidth) {\nblendFactor = (finalUV.x - (1.0 - blendWidth)) / blendWidth;\n}\nif (blendFactor > 0.0) {\nblendFactor = smoothstep(0.0, 1.0, blendFactor);\nvec2 oppositeUV = vec2(finalUV.x > 0.5 ? finalUV.x - 0.5 : finalUV.x + 0.5, finalUV.y);\nvec4 oppositeCol = texture(uTexture, oppositeUV);\ncol = mix(col, oppositeCol, blendFactor);\n}\n}\nreturn col;\n}vec4 getRepeatUV(vec2 uv) {\nreturn getRepeatHorizontalUV(uv);\n}void main() {\nfloat aspect = 2.;\nvec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000 * 0.5);\nvec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect);\nvec2 uvHorizontal = directionToUVHorizontal(rayDir);\nvec2 uvVertical = directionToUVVertical(rayDir);\nvec2 sphereUV = mix(uvHorizontal, uvVertical, 0.5000);\nfloat minFOV = radians(20.0);\nfloat maxFOV = radians(120.0);\nfloat currentFOV = mix(minFOV, maxFOV, 0.0000);\nfloat fovCompensation = tan(currentFOV/2.0);\nfloat compensatedScale = (mix(-0.1, 0.4, 0.1400) * 12.0 + 2.0) * (1.0/fovCompensation);\nsphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(0.18, 0) * uTime * 0.005;vec4 col = getRepeatUV(sphereUV);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"projection"},{"breakpoints":[],"aspectRatio":1,"userDownsample":1,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"98b941d0-5650-47a0-ae03-909c2cb26bca","prop":"width","transition":{"ease":"x => x === 1 ? 1 : 1 - Math.pow(2, -10 * x)","duration":2000,"delay":250},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uWidth","value":512}}],"scroll":[],"hover":[],"mousemove":[]},"effects":["2d375f18-518d-4d94-9a3a-dd4369258581"],"anchorPoint":3,"mask":0,"maskDepthLayer":1,"layerType":"shape","width":1,"widthMode":0,"height":1,"heightMode":0,"left":1,"top":0.5,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uArtboardResolution;\nuniform float uWidth;uniform vec2 uMousePos;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(1.0, 0.5);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return vec3(0, 0, 0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = uWidth * uArtboardResolution.x;\nfloat absHeight = 1.0000 * uArtboardResolution.y;if (0 == 2) {\nabsWidth = absHeight * 1.0000;\n} else if (0 == 2) {\nabsHeight = absWidth / 1.0000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(1.0000, 0.5000) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = rotate2D(canvasPosPx - (elementPosPx + elementSizePx * 0.5), 0.0000 * -TAU) + elementSizePx * 0.5;\nvec2 localSize;\nlocalSize = elementSizePx;\nvec2 centerPx;\ncenterPx = elementPosPx + elementSizePx * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getSourceOutput(vec2 uv) {\nreturn sampleShape(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getSourceOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1}},"compositeShader":{"fragmentShader":"#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0);uv -= pos;vec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}","vertexShader":"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"},"compositeUniforms":{"resolution":{"name":"uResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"opacity":{"name":"uOpacity","type":"1f","value":1},"mousePos":{"name":"uMousePos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) {\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec4 revealTrail(vec2 uv, vec2 mouseDir, float strength) {\nvec4 color = vec4(0);\nfloat zMix = strength;\nvec2 distorted = mouseDir * 0.4 * 0.5100;\nuv -= distorted;\ncolor = texture(uTexture, uv);\ncolor.rgb = chromatic_aberration(color.rgb, uv, distorted * 0.2500 * 0.12);\ncolor = mix(vec4(vec3(0, 0, 0), 1.0000), color, zMix);\nreturn color;\n}vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) {\nvec4 color = vec4(0);return revealTrail(uv, mouseDir, strength);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;\nfloat aspectRatio = uResolution.x / uResolution.y;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (0.5000 * 1.5);\nvec2 direction = angleToDir(angle);\nvec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 aspectVec = vec2(aspectRatio, 1.0);\nvec2 uv = vTextureCoord;\nvec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec;\nfloat dist = length(dir);\nif (dist > 0.0) {\ndir = dir / dist;\n} else {\ndir = vec2(1.0, 0.0);\n}float rad = 0.2600 * 0.4 * mix(aspectRatio, 1.0, 0.5);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec3 lastFrameColor = vec3(0);float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0;\nvec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec;\nfloat distanceToLine = distance(correctedUv, closestPoint);float shrink = mix(0.5, 1.0, clamp(dist * 20.0, 0.0, 1.0));\nrad *= shrink;float s = smoothstep(rad, rad * 0.0000, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.0000 * 0.03) + 0.0000 * 0.015, 0.0000);\nfloat blurRadius = 0.003;\nlastFrameColor = texture(uPingPongTexture, sampleUv).rgb * 0.4;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(blurRadius, 0.0)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(-blurRadius, 0.0)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(0.0, blurRadius)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(0.0, -blurRadius)).rgb * 0.15;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nmouseColor = pow(mouseColor, vec3(2.2));\nlastFrameColor *= pow(0.6700, 0.2);\nfloat clampedDist = clamp(min(1.0, dist * 10.0) * s, 0.0, 1.0);\nvec3 draw = mix(lastFrameColor, mouseColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\nfragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"mouse_trail"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAAoCAYAAADQUaxgAAAQAElEQVR4AeydBZQcRRBAq4MFDx48eHAPDgnuhIcEDUFzuIcQLDgkuCdYCPLQBHcJ7hDc3d1dwv3h9V5N3+7I7szs3qbfu76prq6WrZnpqq6q7ukkIuN88jzwz4B/Bvwz4J+BtM8AAqS1jv/zHPAc8BzwHPAcSMcBL0DS8ctTew5kxwHfkudAB+dA0wuQTp06yQknnCBnn312KJ111ll1v3VLL720DBs2TB577DH57LPP5Pfff5dvv/1WXnjhBbnyyitl5513rusYGd/o0aPlpZdekq+//lr++OMP+e677+S1116T22+/XXbaaae6jq9S5yeeeGLoXnPvF1lkkUrkmeJXW221dn3Tf5J05plnyswzz5zpeNI2dsghh4TGP2TIEJlgggnSNpOanmcpCY+S0HTr1i11/9VUWGWVVeTqq6+Wp556Sj755BP55ZdfggQMjjJoqmk7izozzDCDHHTQQTJq1Ch54403grH99NNPwfs8cuTIYH6ZaqqpauqqqQXIJJNMIq+++qoceuihstdee4XS3nvvXRPjaqk800wzyf333y/PPPOM7LbbbrLCCitI165dhfFOM800sthii8k222wjF110USBYlltuuVq6S123R48e8u677wbj6927tzD5TjfddDLxxBNLly5dpHv37rLeeuvJxRdfHAiWegs6/QOPO+44GThwYOhec+/PP/98TZYbvPvuu7frm/6TpH322Uc222yz3MYW1TATySuvvCInnXRSaPybbrqpTDHFFFFVMyljokvCoyQ0p512WiZjqtTIyiuvHChRDz30kPTp00eWXXZZmWWWWWSyySYLEjA4yqBB4aJOpfbywA8aNEg+/fRTGTp0qHAP559//mBs3Eve5+233z6YX7744gvZaKONqh5CBxYg0b+ZF+Ktt96SBRZYIJqw4NIll1xSPv74Y+nVq1einru2CpYnnnhCmBgTVaiRCIFGf3PNNVeilhAsCDoe1EQVciRCe0dZKNeFMaYcOnMc/Mi80ZwbRGHhmVxooYVCPaFBzzfffPLDDz+E8ONzpqWlRR5++GHp3qpEJeUDtNRBKUxap1o63oH33ntPjj/+eJlwwgljm+ncubPcfPPNcs011wjWmtgKDkFTChCWbu+8847MPvvszs+tb5ZxPfLII+1u7L///husNMaOHSsfffSR/Pnnn+0GikbhvuDtiGpEoDFhUjMmPNn+9ddfwkP53HPPyYcffijk3a7QILfYYgsXXWj+pptuquolyHKQU089dU3N/frrrzXVT1t5nXXWkeeff16mnHLKUlWex1122UW23nrrEs4DEih95513XjtW/P333/L222/LAw88ECRgcC7h5ZdfLnm/w/fee6+4JjzuJ6sRTOUkYHB6fFtuuaUMHz5coxLBTSdAYB7CY/rppw8x4JRTTgl8DCFkwRnMVixzdbc33HBD8PKy7GV1Msccc8ikk04a3Mxx48aVSI0xcvfdd5fyWQOYzq644opQs/TPyofxzD333IJPZM455wzGW+5FwqQVaqDADMILs4HtEluvhYu8agHyzTffiDEmVbrkkksKGy7PGtqn1jxRXrjPcfcyz0HiCzQmOd9coTtmzJhchnf66acH91I3PmLECOHdYaW2+uqrCwkYHGWaFj5ff/31GpUpjAnUFVCPPvqoYDKfddZZZaWVVgoSMDjK9AB23HFHQcnVuDi4qQQIzMPeqLUpGDCw1SZ+8MEHA9YtYSbA9qgHcPLJJ8vmm28u7guAdtC/f3/BganpufFuG7q8Fvi3334TTH66jf3220+OOOII+eeffzQ6cKbvueeegX1VF8B3XhyNKwKeaKKJ5NJLLy11heDD1FBCFAjAA9vdzz//bMGGu+Jve/rppwO/lh0cK8vll19eWAlbXKNfeQ61UkagxznnnJP5sDH18A7rhllRMOmWu8/gKING15lnnnl0NjOY+4mSrBu89tprBd8LATAaDwyOMmjIkxBwmC2Bk6amESA4mnnwudH2xzORYNNnora4el1dx97rr78uCLao8VDOg6hp1lxzTZ3NDEbrQwDblQXRLnGRagMGDGhnbsNhl9mgEjaE8Jh88slL1FdddZW8/PLLpXyRAKs129/3339vwYa7PvjggzLjjDOWxoXJhQgyzFklZAcAXJ8X0YsoYFkPfZlllgmtPphb+vXrF9sNNNBaQgJRUARtPqsr0V4oUrY9IsL69u1rsxWv0EBrCVhB6VW0xVe6NoUAYTmGbU8zkIcIs8aFF15Y6bcXikc7ePbZZyV4mFp73n///Vv/x/8RfqepWIbqfNYwGh3mP5bDSdr+/PPPQ2SLL754KJ93Bq1QOyd5GdD88u63Uvta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","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.8800);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4200), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;\ncol = vec3(0.7411764705882353, 0.7411764705882353, 0.7411764705882353);vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"duotone","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\nvec3 duotoneColor = mix(vec3(1, 1, 1), vec3(0.5647058823529412, 0.8862745098039215, 0.9254901960784314), gray);\ncolor = vec4(mix(color.rgb, duotoneColor, 1.0000), color.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"duotone"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"d317a8d6-624d-4522-ba2f-cda9685f0ab7","prop":"spread","transition":{"delay":250,"duration":1000,"ease":"x => x ** 5"},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uSpread"}}],"scroll":[],"hover":[],"mousemove":[]},"layerType":"effect","type":"voronoi","usesPingPong":false,"spread":1,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"2d375f18-518d-4d94-9a3a-dd4369258581","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uSpread;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nvec2 random2( vec2 p ) {\nreturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}const float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nout vec4 fragColor;vec2 voronoidNoise(vec2 st) {\nvec2 i_st = floor(st);\nvec2 f_st = fract(st);float m_dist = 15.;\nvec2 m_point;\nvec2 d;for (int j=-1; j<=1; j++ ) {\nfor (int i=-1; i<=1; i++ ) {\nvec2 neighbor = vec2(float(i),float(j));\nvec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point);\nvec2 diff = neighbor + point - f_st;\nfloat dist = length(diff);if( dist < m_dist ) {\nm_dist = dist;\nm_point = point;\nd = diff;\n}\n}\n}return m_point;\n}\nvec2 voronoiFBM(vec2 st) {\nvec2 value = vec2(0.0);\nvec2 shift = vec2(100.0);\nfloat xp = sqrt(2.);\nmat2 r = rot(0.5);\nfor (int i = 0; i < 2; i++) {\nvalue += voronoidNoise(st);\nst = st * xp + shift;\nst = r * st;\n}\nreturn value / float(2);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 1.0000);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 0.5000;\nst = st * rot(0.2511 * 2. * PI) * skew;\nvec2 m_point = voronoiFBM(st);vec2 offset = (m_point * 0.2 * uSpread * 2.) - (uSpread * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));vec4 color = texture(uTexture, uv + offset * dist);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"shatter"}],"options":{"name":"Garden (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"C7u79Nfdq5vkMOeyG3gR"}